---
layout: default
title: hw10 for SE
---
# hw10 for SE 抽象数据类型
_by ShoringN_

1. Bubble Sort the list: 33, 56, 17, 8, 95, 22。Make sure the final result is
from small to large.
Write out the list after the 2nd pass. (10 points)
* 伪代码：
```
FOR i FROM data.0 TO data.(length - 1) DO
    FOR j FROM data.(length - i - 1) TO data.(length - 1) DO
	    IF (data[j] > data[j+1]) THEN
		    temp = data[j]
		    data[j] = data[j+1]
	        data[j+1] = temp
	    END IF
	END FOR
END FOR
```
* C语言实现算法
```
int main(){
    int data[6] = {33, 56, 17, 8, 95, 22};
    for(int i = 0; i < 5; ++i){//i-限制最后一位为最大值，不参与排序 
		for(int j = 0; j < (5 - i); ++j){//j-真实的操作量 
			if (data[j] > data[j+1]){
			    int temp; 
		        temp = data[j];
			    data[j] = data[j+1];
		        data[j+1] = temp;
		    }
		}
		if(i == 2){
			for(int j = 0; j < 6; ++j){
				printf("%d ", data[j]);
			}
		}
	}
}
```
* 输出值
```
17 8 33 22 56 95
```

2. Give a sorted array as list={60,65,75,80,90,95}. Design an algorithm to
insert the value of x into the sorted array. Then test the algorithm with
value 50,67,99.

* 二分搜索算法

**使用递归**
```
int BinarySearch(const int arr[], int start, int end, int target){
	int middle = start + (end - start) / 2;//直接求平均可能溢出
	if(target > arr[middle]){
		return BinarySearch(arr, (middle - 1), end, target);
	}
	else if(target < arr[middle]){
		return BinarySearch(arr, start, (middle - 1), target);
	}
	else return middle;
}
```

* 思考：为什么选择插入点在list头上、中间、尾巴上的三个数作为算法测试的数据，你能解释吗？
```
头、中、尾运用了二分搜索算法（Binary Search）。
1. 原数列已排序；
2. 通过移动测试数据的位置进行每次将范围缩小一半，提高查找速率。
```

3. What is the state of the stack after the following sequence of Push and Pop operations?
```
Push “anne” {anne}
Push “get” {anne get}
Push “your” {anne get your}
Pop “your” {anne get}
Push “my” {anne get my}
Push “gun” {anne get my gun}
```
---