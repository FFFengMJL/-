# 溢出、精度与误差

## part 1 溢出与精度误差的判断

已知：

>|数据类型      |数字范围    |
>|:------------|:-----------|
>|int8_t       |[0,127]     |
>|uint8_t      |[0,255]     |

### 1.overflow

1. x,y,z`皆不溢出`。

2. x=0xd3=（16*13+3）<sub>10</sub>=（211）<sub>10</sub>；`溢出`。

3. x=（211）<sub>10</sub>；`不溢出`。

4. x,y`不溢出`;z`溢出`。

### 2.精度误差

5. x=（1.001）<sub>2</sub>，`无精度误差`。

6. x=（10111.0）<sub>2</sub>，`无精度误差`。

7. `有精度误差`。

## part 2 解释及证明

### 1.解释

1. Method of complements:

>In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers. 

>**补数**在数学与计算中，是一种用一个正数之和减去另一个数的技术。

2. Byte:

>The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. 

>**字节**是一个关于数字信息的单元，它一般由8位组成，用来表示一个2进制数。

3. Integer（computer science）:

>In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers. 

>在计算机科学中，**整数**是整数变量类型的基准，是一种表示部分数学上整数的数据类型。

4. Floating point:

>Floating point is used to represent fractional values, or when a wider range is needed than is provided by fixed point (of the same bit width), even if at the cost of precision.

>**浮点**用于表示小数值，或当以减小精度为代价，来表示一个需要更大范围的的数值。

### 2.证明

- 第一题
    - 1. >已知*X*的负数的绝对值与其二进制编码的和为**数据大小上限**，*X*的二进制反码加上原码，结果的位上全为**1**，此时加上1，使得数据大小超过上限，溢出，全部位变成0，此时和的结果为0。
    {:start="2"}
    - 2.  >361

- 第二题
    - 1.  >对于八位大小的整数，已知x超出储存上线，变为复数，十进制中为表示为**-32**，则正数为256-32=224，把224赋值给四字节大小的y，所以y=e0。
    {:start="2"}
    - 2.  >若一个数是在int8_t中为负数，则此数的绝对值加上该数编码所对应的数的和加上1就是该数据的最大自然数个数。
- 第三题
 >In computing, NaN, standing for not a number, is a numeric data type value representing an undefined or unrepresentable value, especially in floating-point calculations. 
>
>在计算特别是浮点数运算中，NaN，并不表示一个数字却是一种代表未定义或未能表示的一种数字数据类型，